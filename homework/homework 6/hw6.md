The approach I used started with sorting the array so that it would be easier to later skip any duplicates we have in the given array. I checked the condition that the array is at least size three. I created the for loop which will iterate until there are two spots ahead of i for the other pointers j and k to have space. The if statement after that checks when i is the second element and so on and that its equal to the previous one. The continue statement inside that will do this until we're no longer at a duplicate. Then we create the j and k which represents the element after i and at the end of the array, repectively. J and k will traverse that subarray and increment/decrement towards each other. While j < k, we're going to add those numbers along with i and check if it's equal to 0 and that they're not duplicates. If this answer is valid, we add it so our list of answers. After this we continue and decrement k. Now if element at k is the same as k + 1, then we're going to decrement k again since it's a duplicate. If the sum wasn't even 0 and it's greater than 0, we're going to decrement k anyways because it's making our sum too large. Lastly, if the sum was too small then just increment j since the sum wasn't big enough. This works because the array was sorted so we can just scrap those numbers if the sum was greater or less than 0.
